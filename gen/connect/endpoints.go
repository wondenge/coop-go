// Code generated by goa v3.1.3, DO NOT EDIT.
//
// connect endpoints
//
// Command:
// $ goa gen github.com/wondenge/coop-go/design

package connect

import (
	"context"

	"github.com/go-kit/kit/endpoint"
	"goa.design/goa/v3/security"
)

// Endpoints wraps the "connect" service endpoints.
type Endpoints struct {
	AccountBalance        endpoint.Endpoint
	AccountFullStatement  endpoint.Endpoint
	AccountMiniStatement  endpoint.Endpoint
	AccountTransactions   endpoint.Endpoint
	AccountValidation     endpoint.Endpoint
	ExchangeRate          endpoint.Endpoint
	IFTAccountToAccount   endpoint.Endpoint
	INSSimulation         endpoint.Endpoint
	PesaLinkSendToAccount endpoint.Endpoint
	PesaLinkSendToPhone   endpoint.Endpoint
	SendToMPesa           endpoint.Endpoint
	TransactionStatus     endpoint.Endpoint
}

// NewEndpoints wraps the methods of the "connect" service with endpoints.
func NewEndpoints(s Service) *Endpoints {
	// Casting service to Auther interface
	a := s.(Auther)
	return &Endpoints{
		AccountBalance:        NewAccountBalanceEndpoint(s, a.OAuth2Auth),
		AccountFullStatement:  NewAccountFullStatementEndpoint(s, a.OAuth2Auth),
		AccountMiniStatement:  NewAccountMiniStatementEndpoint(s, a.OAuth2Auth),
		AccountTransactions:   NewAccountTransactionsEndpoint(s, a.OAuth2Auth),
		AccountValidation:     NewAccountValidationEndpoint(s, a.OAuth2Auth),
		ExchangeRate:          NewExchangeRateEndpoint(s, a.OAuth2Auth),
		IFTAccountToAccount:   NewIFTAccountToAccountEndpoint(s, a.OAuth2Auth),
		INSSimulation:         NewINSSimulationEndpoint(s, a.OAuth2Auth),
		PesaLinkSendToAccount: NewPesaLinkSendToAccountEndpoint(s, a.OAuth2Auth),
		PesaLinkSendToPhone:   NewPesaLinkSendToPhoneEndpoint(s, a.OAuth2Auth),
		SendToMPesa:           NewSendToMPesaEndpoint(s, a.OAuth2Auth),
		TransactionStatus:     NewTransactionStatusEndpoint(s, a.OAuth2Auth),
	}
}

// Use applies the given middleware to all the "connect" service endpoints.
func (e *Endpoints) Use(m func(endpoint.Endpoint) endpoint.Endpoint) {
	e.AccountBalance = m(e.AccountBalance)
	e.AccountFullStatement = m(e.AccountFullStatement)
	e.AccountMiniStatement = m(e.AccountMiniStatement)
	e.AccountTransactions = m(e.AccountTransactions)
	e.AccountValidation = m(e.AccountValidation)
	e.ExchangeRate = m(e.ExchangeRate)
	e.IFTAccountToAccount = m(e.IFTAccountToAccount)
	e.INSSimulation = m(e.INSSimulation)
	e.PesaLinkSendToAccount = m(e.PesaLinkSendToAccount)
	e.PesaLinkSendToPhone = m(e.PesaLinkSendToPhone)
	e.SendToMPesa = m(e.SendToMPesa)
	e.TransactionStatus = m(e.TransactionStatus)
}

// NewAccountBalanceEndpoint returns an endpoint function that calls the method
// "AccountBalance" of service "connect".
func NewAccountBalanceEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*AccountBalancePayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.AccountBalance(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedAccountBalanceSuccessResponse(res, "default")
		return vres, nil
	}
}

// NewAccountFullStatementEndpoint returns an endpoint function that calls the
// method "AccountFullStatement" of service "connect".
func NewAccountFullStatementEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*AccountFullStatementPayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.AccountFullStatement(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedAccountFullStatementSuccessResponse(res, "default")
		return vres, nil
	}
}

// NewAccountMiniStatementEndpoint returns an endpoint function that calls the
// method "AccountMiniStatement" of service "connect".
func NewAccountMiniStatementEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*AccountMiniStatementPayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.AccountMiniStatement(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedAccountMiniStatementSuccessResponse(res, "default")
		return vres, nil
	}
}

// NewAccountTransactionsEndpoint returns an endpoint function that calls the
// method "AccountTransactions" of service "connect".
func NewAccountTransactionsEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*AccountTransactionsPayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.AccountTransactions(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedAccountTransactionsSuccessResponse(res, "default")
		return vres, nil
	}
}

// NewAccountValidationEndpoint returns an endpoint function that calls the
// method "AccountValidation" of service "connect".
func NewAccountValidationEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*AccountValidationPayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.AccountValidation(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedAccountValidationSuccessResponse(res, "default")
		return vres, nil
	}
}

// NewExchangeRateEndpoint returns an endpoint function that calls the method
// "ExchangeRate" of service "connect".
func NewExchangeRateEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*ExchangeRatePayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.ExchangeRate(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedExchangeRateSuccessResponse(res, "default")
		return vres, nil
	}
}

// NewIFTAccountToAccountEndpoint returns an endpoint function that calls the
// method "IFTAccountToAccount" of service "connect".
func NewIFTAccountToAccountEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*IFTAccountToAccountTXNRequest)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.IFTAccountToAccount(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSuccessAcknowledgement(res, "default")
		return vres, nil
	}
}

// NewINSSimulationEndpoint returns an endpoint function that calls the method
// "INSSimulation" of service "connect".
func NewINSSimulationEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*INSTransactionSimulationRequest)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.INSSimulation(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSuccessAcknowledgement(res, "default")
		return vres, nil
	}
}

// NewPesaLinkSendToAccountEndpoint returns an endpoint function that calls the
// method "PesaLinkSendToAccount" of service "connect".
func NewPesaLinkSendToAccountEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*PesaLinkSendToAccountTransactionRequest)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.PesaLinkSendToAccount(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSuccessAcknowledgement(res, "default")
		return vres, nil
	}
}

// NewPesaLinkSendToPhoneEndpoint returns an endpoint function that calls the
// method "PesaLinkSendToPhone" of service "connect".
func NewPesaLinkSendToPhoneEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*PesaLinkSendToPhoneTransactionRequest)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.PesaLinkSendToPhone(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSuccessAcknowledgement(res, "default")
		return vres, nil
	}
}

// NewSendToMPesaEndpoint returns an endpoint function that calls the method
// "SendToMPesa" of service "connect".
func NewSendToMPesaEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*SendToMpesaTransactionRequest)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.SendToMPesa(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSuccessAcknowledgement(res, "default")
		return vres, nil
	}
}

// NewTransactionStatusEndpoint returns an endpoint function that calls the
// method "TransactionStatus" of service "connect".
func NewTransactionStatusEndpoint(s Service, authOAuth2Fn security.AuthOAuth2Func) endpoint.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.(*FTTransactionStatusPayload)
		var err error
		sc := security.OAuth2Scheme{
			Name:           "oauth2",
			Scopes:         []string{},
			RequiredScopes: []string{},
		}
		var token string
		if p.AccessToken != nil {
			token = *p.AccessToken
		}
		ctx, err = authOAuth2Fn(ctx, token, &sc)
		if err != nil {
			return nil, err
		}
		res, err := s.TransactionStatus(ctx, p)
		if err != nil {
			return nil, err
		}
		vres := NewViewedSuccessResponse(res, "default")
		return vres, nil
	}
}
