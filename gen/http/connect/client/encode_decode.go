// Code generated by goa v3.1.3, DO NOT EDIT.
//
// connect HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/wondenge/coop-go/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"

	connect "github.com/wondenge/coop-go/gen/connect"
	connectviews "github.com/wondenge/coop-go/gen/connect/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildAccountBalanceRequest instantiates a HTTP request object with method
// and path set to call the "connect" service "AccountBalance" endpoint
func (c *Client) BuildAccountBalanceRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountBalanceConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "AccountBalance", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountBalanceRequest returns an encoder for requests sent to the
// connect AccountBalance server.
func EncodeAccountBalanceRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.AccountBalancePayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "AccountBalance", "*connect.AccountBalancePayload", v)
		}
		body := NewAccountBalanceRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "AccountBalance", err)
		}
		return nil
	}
}

// DecodeAccountBalanceResponse returns a decoder for responses returned by the
// connect AccountBalance endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeAccountBalanceResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeAccountBalanceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AccountBalanceResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountBalance", err)
			}
			p := NewAccountBalanceSuccessResponseViewOK(&body)
			view := "default"
			vres := &connectviews.AccountBalanceSuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateAccountBalanceSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountBalance", err)
			}
			res := connect.NewAccountBalanceSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body AccountBalanceBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountBalance", err)
			}
			err = ValidateAccountBalanceBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountBalance", err)
			}
			return nil, NewAccountBalanceBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body AccountBalanceUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountBalance", err)
			}
			return nil, NewAccountBalanceUnauthorized(&body)
		case http.StatusMethodNotAllowed:
			var (
				body AccountBalanceNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountBalance", err)
			}
			err = ValidateAccountBalanceNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountBalance", err)
			}
			return nil, NewAccountBalanceNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body AccountBalanceTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountBalance", err)
			}
			err = ValidateAccountBalanceTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountBalance", err)
			}
			return nil, NewAccountBalanceTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "AccountBalance", resp.StatusCode, string(body))
		}
	}
}

// BuildAccountFullStatementRequest instantiates a HTTP request object with
// method and path set to call the "connect" service "AccountFullStatement"
// endpoint
func (c *Client) BuildAccountFullStatementRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountFullStatementConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "AccountFullStatement", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountFullStatementRequest returns an encoder for requests sent to
// the connect AccountFullStatement server.
func EncodeAccountFullStatementRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.AccountFullStatementPayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "AccountFullStatement", "*connect.AccountFullStatementPayload", v)
		}
		body := NewAccountFullStatementRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "AccountFullStatement", err)
		}
		return nil
	}
}

// DecodeAccountFullStatementResponse returns a decoder for responses returned
// by the connect AccountFullStatement endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeAccountFullStatementResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeAccountFullStatementResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AccountFullStatementResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountFullStatement", err)
			}
			p := NewAccountFullStatementSuccessResponseViewOK(&body)
			view := "default"
			vres := &connectviews.AccountFullStatementSuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateAccountFullStatementSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountFullStatement", err)
			}
			res := connect.NewAccountFullStatementSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body AccountFullStatementBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountFullStatement", err)
			}
			err = ValidateAccountFullStatementBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountFullStatement", err)
			}
			return nil, NewAccountFullStatementBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body AccountFullStatementUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountFullStatement", err)
			}
			return nil, NewAccountFullStatementUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body AccountFullStatementNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountFullStatement", err)
			}
			err = ValidateAccountFullStatementNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountFullStatement", err)
			}
			return nil, NewAccountFullStatementNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body AccountFullStatementNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountFullStatement", err)
			}
			err = ValidateAccountFullStatementNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountFullStatement", err)
			}
			return nil, NewAccountFullStatementNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body AccountFullStatementTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountFullStatement", err)
			}
			err = ValidateAccountFullStatementTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountFullStatement", err)
			}
			return nil, NewAccountFullStatementTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "AccountFullStatement", resp.StatusCode, string(body))
		}
	}
}

// BuildAccountMiniStatementRequest instantiates a HTTP request object with
// method and path set to call the "connect" service "AccountMiniStatement"
// endpoint
func (c *Client) BuildAccountMiniStatementRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountMiniStatementConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "AccountMiniStatement", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountMiniStatementRequest returns an encoder for requests sent to
// the connect AccountMiniStatement server.
func EncodeAccountMiniStatementRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.AccountMiniStatementPayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "AccountMiniStatement", "*connect.AccountMiniStatementPayload", v)
		}
		body := NewAccountMiniStatementRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "AccountMiniStatement", err)
		}
		return nil
	}
}

// DecodeAccountMiniStatementResponse returns a decoder for responses returned
// by the connect AccountMiniStatement endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeAccountMiniStatementResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeAccountMiniStatementResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AccountMiniStatementResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountMiniStatement", err)
			}
			p := NewAccountMiniStatementSuccessResponseViewOK(&body)
			view := "default"
			vres := &connectviews.AccountMiniStatementSuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateAccountMiniStatementSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountMiniStatement", err)
			}
			res := connect.NewAccountMiniStatementSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body AccountMiniStatementBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountMiniStatement", err)
			}
			err = ValidateAccountMiniStatementBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountMiniStatement", err)
			}
			return nil, NewAccountMiniStatementBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body AccountMiniStatementUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountMiniStatement", err)
			}
			return nil, NewAccountMiniStatementUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body AccountMiniStatementNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountMiniStatement", err)
			}
			err = ValidateAccountMiniStatementNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountMiniStatement", err)
			}
			return nil, NewAccountMiniStatementNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body AccountMiniStatementNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountMiniStatement", err)
			}
			err = ValidateAccountMiniStatementNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountMiniStatement", err)
			}
			return nil, NewAccountMiniStatementNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body AccountMiniStatementTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountMiniStatement", err)
			}
			err = ValidateAccountMiniStatementTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountMiniStatement", err)
			}
			return nil, NewAccountMiniStatementTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "AccountMiniStatement", resp.StatusCode, string(body))
		}
	}
}

// BuildAccountTransactionsRequest instantiates a HTTP request object with
// method and path set to call the "connect" service "AccountTransactions"
// endpoint
func (c *Client) BuildAccountTransactionsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountTransactionsConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "AccountTransactions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountTransactionsRequest returns an encoder for requests sent to the
// connect AccountTransactions server.
func EncodeAccountTransactionsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.AccountTransactionsPayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "AccountTransactions", "*connect.AccountTransactionsPayload", v)
		}
		body := NewAccountTransactionsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "AccountTransactions", err)
		}
		return nil
	}
}

// DecodeAccountTransactionsResponse returns a decoder for responses returned
// by the connect AccountTransactions endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeAccountTransactionsResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeAccountTransactionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AccountTransactionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountTransactions", err)
			}
			p := NewAccountTransactionsSuccessResponseViewOK(&body)
			view := "default"
			vres := &connectviews.AccountTransactionsSuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateAccountTransactionsSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountTransactions", err)
			}
			res := connect.NewAccountTransactionsSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body AccountTransactionsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountTransactions", err)
			}
			err = ValidateAccountTransactionsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountTransactions", err)
			}
			return nil, NewAccountTransactionsBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body AccountTransactionsUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountTransactions", err)
			}
			return nil, NewAccountTransactionsUnauthorized(&body)
		case http.StatusMethodNotAllowed:
			var (
				body AccountTransactionsNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountTransactions", err)
			}
			err = ValidateAccountTransactionsNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountTransactions", err)
			}
			return nil, NewAccountTransactionsNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body AccountTransactionsTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountTransactions", err)
			}
			err = ValidateAccountTransactionsTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountTransactions", err)
			}
			return nil, NewAccountTransactionsTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "AccountTransactions", resp.StatusCode, string(body))
		}
	}
}

// BuildAccountValidationRequest instantiates a HTTP request object with method
// and path set to call the "connect" service "AccountValidation" endpoint
func (c *Client) BuildAccountValidationRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AccountValidationConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "AccountValidation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAccountValidationRequest returns an encoder for requests sent to the
// connect AccountValidation server.
func EncodeAccountValidationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.AccountValidationPayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "AccountValidation", "*connect.AccountValidationPayload", v)
		}
		body := NewAccountValidationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "AccountValidation", err)
		}
		return nil
	}
}

// DecodeAccountValidationResponse returns a decoder for responses returned by
// the connect AccountValidation endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeAccountValidationResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeAccountValidationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AccountValidationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountValidation", err)
			}
			p := NewAccountValidationSuccessResponseViewOK(&body)
			view := "default"
			vres := &connectviews.AccountValidationSuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateAccountValidationSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountValidation", err)
			}
			res := connect.NewAccountValidationSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body AccountValidationBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountValidation", err)
			}
			err = ValidateAccountValidationBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountValidation", err)
			}
			return nil, NewAccountValidationBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body AccountValidationUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountValidation", err)
			}
			return nil, NewAccountValidationUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body AccountValidationNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountValidation", err)
			}
			err = ValidateAccountValidationNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountValidation", err)
			}
			return nil, NewAccountValidationNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body AccountValidationNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountValidation", err)
			}
			err = ValidateAccountValidationNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountValidation", err)
			}
			return nil, NewAccountValidationNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body AccountValidationTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "AccountValidation", err)
			}
			err = ValidateAccountValidationTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "AccountValidation", err)
			}
			return nil, NewAccountValidationTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "AccountValidation", resp.StatusCode, string(body))
		}
	}
}

// BuildExchangeRateRequest instantiates a HTTP request object with method and
// path set to call the "connect" service "ExchangeRate" endpoint
func (c *Client) BuildExchangeRateRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ExchangeRateConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "ExchangeRate", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeExchangeRateRequest returns an encoder for requests sent to the
// connect ExchangeRate server.
func EncodeExchangeRateRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.ExchangeRatePayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "ExchangeRate", "*connect.ExchangeRatePayload", v)
		}
		body := NewExchangeRateRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "ExchangeRate", err)
		}
		return nil
	}
}

// DecodeExchangeRateResponse returns a decoder for responses returned by the
// connect ExchangeRate endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeExchangeRateResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeExchangeRateResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ExchangeRateResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "ExchangeRate", err)
			}
			p := NewExchangeRateSuccessResponseViewOK(&body)
			view := "default"
			vres := &connectviews.ExchangeRateSuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateExchangeRateSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "ExchangeRate", err)
			}
			res := connect.NewExchangeRateSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ExchangeRateBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "ExchangeRate", err)
			}
			err = ValidateExchangeRateBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "ExchangeRate", err)
			}
			return nil, NewExchangeRateBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body ExchangeRateUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "ExchangeRate", err)
			}
			return nil, NewExchangeRateUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body ExchangeRateNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "ExchangeRate", err)
			}
			err = ValidateExchangeRateNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "ExchangeRate", err)
			}
			return nil, NewExchangeRateNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body ExchangeRateNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "ExchangeRate", err)
			}
			err = ValidateExchangeRateNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "ExchangeRate", err)
			}
			return nil, NewExchangeRateNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body ExchangeRateTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "ExchangeRate", err)
			}
			err = ValidateExchangeRateTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "ExchangeRate", err)
			}
			return nil, NewExchangeRateTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "ExchangeRate", resp.StatusCode, string(body))
		}
	}
}

// BuildIFTAccountToAccountRequest instantiates a HTTP request object with
// method and path set to call the "connect" service "IFTAccountToAccount"
// endpoint
func (c *Client) BuildIFTAccountToAccountRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: IFTAccountToAccountConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "IFTAccountToAccount", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeIFTAccountToAccountRequest returns an encoder for requests sent to the
// connect IFTAccountToAccount server.
func EncodeIFTAccountToAccountRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.IFTAccountToAccountTXNRequest)
		if !ok {
			return goahttp.ErrInvalidType("connect", "IFTAccountToAccount", "*connect.IFTAccountToAccountTXNRequest", v)
		}
		body := NewIFTAccountToAccountRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "IFTAccountToAccount", err)
		}
		return nil
	}
}

// DecodeIFTAccountToAccountResponse returns a decoder for responses returned
// by the connect IFTAccountToAccount endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeIFTAccountToAccountResponse may return the following errors:
//	- "bad_request" (type *connect.AcknowledgementError400): http.StatusBadRequest
//	- "forbidden" (type *connect.AcknowledgementError403): http.StatusForbidden
//	- "conflict" (type *connect.AcknowledgementError409): http.StatusConflict
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeIFTAccountToAccountResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body IFTAccountToAccountResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			p := NewIFTAccountToAccountSuccessAcknowledgementOK(&body)
			view := "default"
			vres := &connectviews.SuccessAcknowledgement{Projected: p, View: view}
			if err = connectviews.ValidateSuccessAcknowledgement(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			res := connect.NewSuccessAcknowledgement(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body IFTAccountToAccountBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			err = ValidateIFTAccountToAccountBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountBadRequest(&body)
		case http.StatusForbidden:
			var (
				body IFTAccountToAccountForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			err = ValidateIFTAccountToAccountForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountForbidden(&body)
		case http.StatusConflict:
			var (
				body IFTAccountToAccountConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			err = ValidateIFTAccountToAccountConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountConflict(&body)
		case http.StatusUnauthorized:
			var (
				body IFTAccountToAccountUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body IFTAccountToAccountNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			err = ValidateIFTAccountToAccountNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body IFTAccountToAccountNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			err = ValidateIFTAccountToAccountNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body IFTAccountToAccountTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "IFTAccountToAccount", err)
			}
			err = ValidateIFTAccountToAccountTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "IFTAccountToAccount", err)
			}
			return nil, NewIFTAccountToAccountTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "IFTAccountToAccount", resp.StatusCode, string(body))
		}
	}
}

// BuildINSSimulationRequest instantiates a HTTP request object with method and
// path set to call the "connect" service "INSSimulation" endpoint
func (c *Client) BuildINSSimulationRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: INSSimulationConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "INSSimulation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeINSSimulationRequest returns an encoder for requests sent to the
// connect INSSimulation server.
func EncodeINSSimulationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.INSTransactionSimulationRequest)
		if !ok {
			return goahttp.ErrInvalidType("connect", "INSSimulation", "*connect.INSTransactionSimulationRequest", v)
		}
		body := NewINSSimulationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "INSSimulation", err)
		}
		return nil
	}
}

// DecodeINSSimulationResponse returns a decoder for responses returned by the
// connect INSSimulation endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeINSSimulationResponse may return the following errors:
//	- "unauthorized" (type *connect.ErrorAcknowledgement): http.StatusUnauthorized
//	- "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeINSSimulationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body INSSimulationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "INSSimulation", err)
			}
			p := NewINSSimulationSuccessAcknowledgementOK(&body)
			view := "default"
			vres := &connectviews.SuccessAcknowledgement{Projected: p, View: view}
			if err = connectviews.ValidateSuccessAcknowledgement(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "INSSimulation", err)
			}
			res := connect.NewSuccessAcknowledgement(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body INSSimulationUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "INSSimulation", err)
			}
			err = ValidateINSSimulationUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "INSSimulation", err)
			}
			return nil, NewINSSimulationUnauthorized(&body)
		case http.StatusBadRequest:
			var (
				body INSSimulationBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "INSSimulation", err)
			}
			err = ValidateINSSimulationBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "INSSimulation", err)
			}
			return nil, NewINSSimulationBadRequest(&body)
		case http.StatusMethodNotAllowed:
			var (
				body INSSimulationNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "INSSimulation", err)
			}
			err = ValidateINSSimulationNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "INSSimulation", err)
			}
			return nil, NewINSSimulationNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body INSSimulationTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "INSSimulation", err)
			}
			err = ValidateINSSimulationTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "INSSimulation", err)
			}
			return nil, NewINSSimulationTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "INSSimulation", resp.StatusCode, string(body))
		}
	}
}

// BuildPesaLinkSendToAccountRequest instantiates a HTTP request object with
// method and path set to call the "connect" service "PesaLinkSendToAccount"
// endpoint
func (c *Client) BuildPesaLinkSendToAccountRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PesaLinkSendToAccountConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "PesaLinkSendToAccount", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePesaLinkSendToAccountRequest returns an encoder for requests sent to
// the connect PesaLinkSendToAccount server.
func EncodePesaLinkSendToAccountRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.PesaLinkSendToAccountTransactionRequest)
		if !ok {
			return goahttp.ErrInvalidType("connect", "PesaLinkSendToAccount", "*connect.PesaLinkSendToAccountTransactionRequest", v)
		}
		body := NewPesaLinkSendToAccountRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "PesaLinkSendToAccount", err)
		}
		return nil
	}
}

// DecodePesaLinkSendToAccountResponse returns a decoder for responses returned
// by the connect PesaLinkSendToAccount endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodePesaLinkSendToAccountResponse may return the following errors:
//	- "bad_request" (type *connect.AcknowledgementError400): http.StatusBadRequest
//	- "forbidden" (type *connect.AcknowledgementError403): http.StatusForbidden
//	- "conflict" (type *connect.AcknowledgementError409): http.StatusConflict
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodePesaLinkSendToAccountResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body PesaLinkSendToAccountResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			p := NewPesaLinkSendToAccountSuccessAcknowledgementOK(&body)
			view := "default"
			vres := &connectviews.SuccessAcknowledgement{Projected: p, View: view}
			if err = connectviews.ValidateSuccessAcknowledgement(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			res := connect.NewSuccessAcknowledgement(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body PesaLinkSendToAccountBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			err = ValidatePesaLinkSendToAccountBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountBadRequest(&body)
		case http.StatusForbidden:
			var (
				body PesaLinkSendToAccountForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			err = ValidatePesaLinkSendToAccountForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountForbidden(&body)
		case http.StatusConflict:
			var (
				body PesaLinkSendToAccountConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			err = ValidatePesaLinkSendToAccountConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountConflict(&body)
		case http.StatusUnauthorized:
			var (
				body PesaLinkSendToAccountUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body PesaLinkSendToAccountNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			err = ValidatePesaLinkSendToAccountNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body PesaLinkSendToAccountNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			err = ValidatePesaLinkSendToAccountNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body PesaLinkSendToAccountTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToAccount", err)
			}
			err = ValidatePesaLinkSendToAccountTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToAccount", err)
			}
			return nil, NewPesaLinkSendToAccountTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "PesaLinkSendToAccount", resp.StatusCode, string(body))
		}
	}
}

// BuildPesaLinkSendToPhoneRequest instantiates a HTTP request object with
// method and path set to call the "connect" service "PesaLinkSendToPhone"
// endpoint
func (c *Client) BuildPesaLinkSendToPhoneRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PesaLinkSendToPhoneConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "PesaLinkSendToPhone", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePesaLinkSendToPhoneRequest returns an encoder for requests sent to the
// connect PesaLinkSendToPhone server.
func EncodePesaLinkSendToPhoneRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.PesaLinkSendToPhoneTransactionRequest)
		if !ok {
			return goahttp.ErrInvalidType("connect", "PesaLinkSendToPhone", "*connect.PesaLinkSendToPhoneTransactionRequest", v)
		}
		body := NewPesaLinkSendToPhoneRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "PesaLinkSendToPhone", err)
		}
		return nil
	}
}

// DecodePesaLinkSendToPhoneResponse returns a decoder for responses returned
// by the connect PesaLinkSendToPhone endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodePesaLinkSendToPhoneResponse may return the following errors:
//	- "bad_request" (type *connect.AcknowledgementError400): http.StatusBadRequest
//	- "forbidden" (type *connect.AcknowledgementError403): http.StatusForbidden
//	- "conflict" (type *connect.AcknowledgementError409): http.StatusConflict
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodePesaLinkSendToPhoneResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body PesaLinkSendToPhoneResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			p := NewPesaLinkSendToPhoneSuccessAcknowledgementOK(&body)
			view := "default"
			vres := &connectviews.SuccessAcknowledgement{Projected: p, View: view}
			if err = connectviews.ValidateSuccessAcknowledgement(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			res := connect.NewSuccessAcknowledgement(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body PesaLinkSendToPhoneBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			err = ValidatePesaLinkSendToPhoneBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneBadRequest(&body)
		case http.StatusForbidden:
			var (
				body PesaLinkSendToPhoneForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			err = ValidatePesaLinkSendToPhoneForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneForbidden(&body)
		case http.StatusConflict:
			var (
				body PesaLinkSendToPhoneConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			err = ValidatePesaLinkSendToPhoneConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneConflict(&body)
		case http.StatusUnauthorized:
			var (
				body PesaLinkSendToPhoneUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body PesaLinkSendToPhoneNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			err = ValidatePesaLinkSendToPhoneNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body PesaLinkSendToPhoneNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			err = ValidatePesaLinkSendToPhoneNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body PesaLinkSendToPhoneTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "PesaLinkSendToPhone", err)
			}
			err = ValidatePesaLinkSendToPhoneTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "PesaLinkSendToPhone", err)
			}
			return nil, NewPesaLinkSendToPhoneTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "PesaLinkSendToPhone", resp.StatusCode, string(body))
		}
	}
}

// BuildSendToMPesaRequest instantiates a HTTP request object with method and
// path set to call the "connect" service "SendToMPesa" endpoint
func (c *Client) BuildSendToMPesaRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SendToMPesaConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "SendToMPesa", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSendToMPesaRequest returns an encoder for requests sent to the connect
// SendToMPesa server.
func EncodeSendToMPesaRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.SendToMpesaTransactionRequest)
		if !ok {
			return goahttp.ErrInvalidType("connect", "SendToMPesa", "*connect.SendToMpesaTransactionRequest", v)
		}
		body := NewSendToMPesaRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "SendToMPesa", err)
		}
		return nil
	}
}

// DecodeSendToMPesaResponse returns a decoder for responses returned by the
// connect SendToMPesa endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeSendToMPesaResponse may return the following errors:
//	- "bad_request" (type *connect.AcknowledgementError400): http.StatusBadRequest
//	- "forbidden" (type *connect.AcknowledgementError403): http.StatusForbidden
//	- "conflict" (type *connect.AcknowledgementError409): http.StatusConflict
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeSendToMPesaResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SendToMPesaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			p := NewSendToMPesaSuccessAcknowledgementOK(&body)
			view := "default"
			vres := &connectviews.SuccessAcknowledgement{Projected: p, View: view}
			if err = connectviews.ValidateSuccessAcknowledgement(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			res := connect.NewSuccessAcknowledgement(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body SendToMPesaBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			err = ValidateSendToMPesaBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaBadRequest(&body)
		case http.StatusForbidden:
			var (
				body SendToMPesaForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			err = ValidateSendToMPesaForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaForbidden(&body)
		case http.StatusConflict:
			var (
				body SendToMPesaConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			err = ValidateSendToMPesaConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaConflict(&body)
		case http.StatusUnauthorized:
			var (
				body SendToMPesaUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body SendToMPesaNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			err = ValidateSendToMPesaNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body SendToMPesaNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			err = ValidateSendToMPesaNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body SendToMPesaTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "SendToMPesa", err)
			}
			err = ValidateSendToMPesaTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "SendToMPesa", err)
			}
			return nil, NewSendToMPesaTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "SendToMPesa", resp.StatusCode, string(body))
		}
	}
}

// BuildTransactionStatusRequest instantiates a HTTP request object with method
// and path set to call the "connect" service "TransactionStatus" endpoint
func (c *Client) BuildTransactionStatusRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: TransactionStatusConnectPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("connect", "TransactionStatus", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeTransactionStatusRequest returns an encoder for requests sent to the
// connect TransactionStatus server.
func EncodeTransactionStatusRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*connect.FTTransactionStatusPayload)
		if !ok {
			return goahttp.ErrInvalidType("connect", "TransactionStatus", "*connect.FTTransactionStatusPayload", v)
		}
		body := NewTransactionStatusRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("connect", "TransactionStatus", err)
		}
		return nil
	}
}

// DecodeTransactionStatusResponse returns a decoder for responses returned by
// the connect TransactionStatus endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeTransactionStatusResponse may return the following errors:
//	- "bad_request" (type *connect.ErrorResponse): http.StatusBadRequest
//	- "unauthorized" (type *connect.MissingCredentials): http.StatusUnauthorized
//	- "not_found" (type *connect.NotFoundErrorResponse): http.StatusNotFound
//	- "not_allowed" (type *goa.ServiceError): http.StatusMethodNotAllowed
//	- "timeout" (type *goa.ServiceError): http.StatusRequestTimeout
//	- error: internal error
func DecodeTransactionStatusResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body TransactionStatusOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "TransactionStatus", err)
			}
			p := NewTransactionStatusSuccessResponseOK(&body)
			view := "default"
			vres := &connectviews.SuccessResponse{Projected: p, View: view}
			if err = connectviews.ValidateSuccessResponse(vres); err != nil {
				return nil, goahttp.ErrValidationError("connect", "TransactionStatus", err)
			}
			res := connect.NewSuccessResponse(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body TransactionStatusBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "TransactionStatus", err)
			}
			err = ValidateTransactionStatusBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "TransactionStatus", err)
			}
			return nil, NewTransactionStatusBadRequest(&body)
		case http.StatusUnauthorized:
			var (
				body TransactionStatusUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "TransactionStatus", err)
			}
			return nil, NewTransactionStatusUnauthorized(&body)
		case http.StatusNotFound:
			var (
				body TransactionStatusNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "TransactionStatus", err)
			}
			err = ValidateTransactionStatusNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "TransactionStatus", err)
			}
			return nil, NewTransactionStatusNotFound(&body)
		case http.StatusMethodNotAllowed:
			var (
				body TransactionStatusNotAllowedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "TransactionStatus", err)
			}
			err = ValidateTransactionStatusNotAllowedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "TransactionStatus", err)
			}
			return nil, NewTransactionStatusNotAllowed(&body)
		case http.StatusRequestTimeout:
			var (
				body TransactionStatusTimeoutResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("connect", "TransactionStatus", err)
			}
			err = ValidateTransactionStatusTimeoutResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("connect", "TransactionStatus", err)
			}
			return nil, NewTransactionStatusTimeout(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("connect", "TransactionStatus", resp.StatusCode, string(body))
		}
	}
}

// unmarshalMissingCredentialFaultResponseBodyToConnectMissingCredentialFault
// builds a value of type *connect.MissingCredentialFault from a value of type
// *MissingCredentialFaultResponseBody.
func unmarshalMissingCredentialFaultResponseBodyToConnectMissingCredentialFault(v *MissingCredentialFaultResponseBody) *connect.MissingCredentialFault {
	if v == nil {
		return nil
	}
	res := &connect.MissingCredentialFault{
		Code:        v.Code,
		Message:     v.Message,
		Description: v.Description,
	}

	return res
}

// unmarshalAccountTransactionResponseBodyToConnectviewsAccountTransactionView
// builds a value of type *connectviews.AccountTransactionView from a value of
// type *AccountTransactionResponseBody.
func unmarshalAccountTransactionResponseBodyToConnectviewsAccountTransactionView(v *AccountTransactionResponseBody) *connectviews.AccountTransactionView {
	if v == nil {
		return nil
	}
	res := &connectviews.AccountTransactionView{
		TransactionID:         v.TransactionID,
		TransactionDate:       v.TransactionDate,
		ValueDate:             v.ValueDate,
		Narration:             v.Narration,
		TransactionType:       v.TransactionType,
		ServicePoint:          v.ServicePoint,
		TransactionReference:  v.TransactionReference,
		CreditAmount:          v.CreditAmount,
		DebitAmount:           v.DebitAmount,
		RunningClearedBalance: v.RunningClearedBalance,
		RunningBookBalance:    v.RunningBookBalance,
		DebitLimit:            v.DebitLimit,
		LimitExpiryDate:       v.LimitExpiryDate,
	}

	return res
}

// marshalConnectSourceAccountTXNRequestToSourceAccountTXNRequestRequestBody
// builds a value of type *SourceAccountTXNRequestRequestBody from a value of
// type *connect.SourceAccountTXNRequest.
func marshalConnectSourceAccountTXNRequestToSourceAccountTXNRequestRequestBody(v *connect.SourceAccountTXNRequest) *SourceAccountTXNRequestRequestBody {
	res := &SourceAccountTXNRequestRequestBody{
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
	}

	return res
}

// marshalConnectDestinationsTXNRequestToDestinationsTXNRequestRequestBody
// builds a value of type *DestinationsTXNRequestRequestBody from a value of
// type *connect.DestinationsTXNRequest.
func marshalConnectDestinationsTXNRequestToDestinationsTXNRequestRequestBody(v *connect.DestinationsTXNRequest) *DestinationsTXNRequestRequestBody {
	res := &DestinationsTXNRequestRequestBody{}
	if v.DestinationsTXNRequest != nil {
		res.DestinationsTXNRequest = make([]*DestinationAccountTXNRequestRequestBody, len(v.DestinationsTXNRequest))
		for i, val := range v.DestinationsTXNRequest {
			res.DestinationsTXNRequest[i] = marshalConnectDestinationAccountTXNRequestToDestinationAccountTXNRequestRequestBody(val)
		}
	}

	return res
}

// marshalConnectDestinationAccountTXNRequestToDestinationAccountTXNRequestRequestBody
// builds a value of type *DestinationAccountTXNRequestRequestBody from a value
// of type *connect.DestinationAccountTXNRequest.
func marshalConnectDestinationAccountTXNRequestToDestinationAccountTXNRequestRequestBody(v *connect.DestinationAccountTXNRequest) *DestinationAccountTXNRequestRequestBody {
	if v == nil {
		return nil
	}
	res := &DestinationAccountTXNRequestRequestBody{
		ReferenceNumber:     v.ReferenceNumber,
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
	}

	return res
}

// marshalSourceAccountTXNRequestRequestBodyToConnectSourceAccountTXNRequest
// builds a value of type *connect.SourceAccountTXNRequest from a value of type
// *SourceAccountTXNRequestRequestBody.
func marshalSourceAccountTXNRequestRequestBodyToConnectSourceAccountTXNRequest(v *SourceAccountTXNRequestRequestBody) *connect.SourceAccountTXNRequest {
	res := &connect.SourceAccountTXNRequest{
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
	}

	return res
}

// marshalDestinationsTXNRequestRequestBodyToConnectDestinationsTXNRequest
// builds a value of type *connect.DestinationsTXNRequest from a value of type
// *DestinationsTXNRequestRequestBody.
func marshalDestinationsTXNRequestRequestBodyToConnectDestinationsTXNRequest(v *DestinationsTXNRequestRequestBody) *connect.DestinationsTXNRequest {
	res := &connect.DestinationsTXNRequest{}
	if v.DestinationsTXNRequest != nil {
		res.DestinationsTXNRequest = make([]*connect.DestinationAccountTXNRequest, len(v.DestinationsTXNRequest))
		for i, val := range v.DestinationsTXNRequest {
			res.DestinationsTXNRequest[i] = marshalDestinationAccountTXNRequestRequestBodyToConnectDestinationAccountTXNRequest(val)
		}
	}

	return res
}

// marshalDestinationAccountTXNRequestRequestBodyToConnectDestinationAccountTXNRequest
// builds a value of type *connect.DestinationAccountTXNRequest from a value of
// type *DestinationAccountTXNRequestRequestBody.
func marshalDestinationAccountTXNRequestRequestBodyToConnectDestinationAccountTXNRequest(v *DestinationAccountTXNRequestRequestBody) *connect.DestinationAccountTXNRequest {
	if v == nil {
		return nil
	}
	res := &connect.DestinationAccountTXNRequest{
		ReferenceNumber:     v.ReferenceNumber,
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
	}

	return res
}

// marshalConnectCustMemoToCustMemoRequestBody builds a value of type
// *CustMemoRequestBody from a value of type *connect.CustMemo.
func marshalConnectCustMemoToCustMemoRequestBody(v *connect.CustMemo) *CustMemoRequestBody {
	res := &CustMemoRequestBody{
		CustMemoLine1: v.CustMemoLine1,
		CustMemoLine2: v.CustMemoLine2,
		CustMemoLine3: v.CustMemoLine3,
	}

	return res
}

// marshalCustMemoRequestBodyToConnectCustMemo builds a value of type
// *connect.CustMemo from a value of type *CustMemoRequestBody.
func marshalCustMemoRequestBodyToConnectCustMemo(v *CustMemoRequestBody) *connect.CustMemo {
	res := &connect.CustMemo{
		CustMemoLine1: v.CustMemoLine1,
		CustMemoLine2: v.CustMemoLine2,
		CustMemoLine3: v.CustMemoLine3,
	}

	return res
}

// marshalConnectSourceAccountTransactionRequestToSourceAccountTransactionRequestRequestBody
// builds a value of type *SourceAccountTransactionRequestRequestBody from a
// value of type *connect.SourceAccountTransactionRequest.
func marshalConnectSourceAccountTransactionRequestToSourceAccountTransactionRequestRequestBody(v *connect.SourceAccountTransactionRequest) *SourceAccountTransactionRequestRequestBody {
	res := &SourceAccountTransactionRequestRequestBody{
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}

// marshalConnectDestinationsTransactionRequestToDestinationsTransactionRequestRequestBody
// builds a value of type *DestinationsTransactionRequestRequestBody from a
// value of type *connect.DestinationsTransactionRequest.
func marshalConnectDestinationsTransactionRequestToDestinationsTransactionRequestRequestBody(v *connect.DestinationsTransactionRequest) *DestinationsTransactionRequestRequestBody {
	res := &DestinationsTransactionRequestRequestBody{}
	if v.DestinationAccountTransactionRequest != nil {
		res.DestinationAccountTransactionRequest = make([]*DestinationAccountTransactionRequestRequestBody, len(v.DestinationAccountTransactionRequest))
		for i, val := range v.DestinationAccountTransactionRequest {
			res.DestinationAccountTransactionRequest[i] = marshalConnectDestinationAccountTransactionRequestToDestinationAccountTransactionRequestRequestBody(val)
		}
	}

	return res
}

// marshalConnectDestinationAccountTransactionRequestToDestinationAccountTransactionRequestRequestBody
// builds a value of type *DestinationAccountTransactionRequestRequestBody from
// a value of type *connect.DestinationAccountTransactionRequest.
func marshalConnectDestinationAccountTransactionRequestToDestinationAccountTransactionRequestRequestBody(v *connect.DestinationAccountTransactionRequest) *DestinationAccountTransactionRequestRequestBody {
	if v == nil {
		return nil
	}
	res := &DestinationAccountTransactionRequestRequestBody{
		ReferenceNumber: v.ReferenceNumber,
		MobileNumber:    v.MobileNumber,
		Amount:          v.Amount,
		Narration:       v.Narration,
	}

	return res
}

// marshalSourceAccountTransactionRequestRequestBodyToConnectSourceAccountTransactionRequest
// builds a value of type *connect.SourceAccountTransactionRequest from a value
// of type *SourceAccountTransactionRequestRequestBody.
func marshalSourceAccountTransactionRequestRequestBodyToConnectSourceAccountTransactionRequest(v *SourceAccountTransactionRequestRequestBody) *connect.SourceAccountTransactionRequest {
	res := &connect.SourceAccountTransactionRequest{
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}

// marshalDestinationsTransactionRequestRequestBodyToConnectDestinationsTransactionRequest
// builds a value of type *connect.DestinationsTransactionRequest from a value
// of type *DestinationsTransactionRequestRequestBody.
func marshalDestinationsTransactionRequestRequestBodyToConnectDestinationsTransactionRequest(v *DestinationsTransactionRequestRequestBody) *connect.DestinationsTransactionRequest {
	res := &connect.DestinationsTransactionRequest{}
	if v.DestinationAccountTransactionRequest != nil {
		res.DestinationAccountTransactionRequest = make([]*connect.DestinationAccountTransactionRequest, len(v.DestinationAccountTransactionRequest))
		for i, val := range v.DestinationAccountTransactionRequest {
			res.DestinationAccountTransactionRequest[i] = marshalDestinationAccountTransactionRequestRequestBodyToConnectDestinationAccountTransactionRequest(val)
		}
	}

	return res
}

// marshalDestinationAccountTransactionRequestRequestBodyToConnectDestinationAccountTransactionRequest
// builds a value of type *connect.DestinationAccountTransactionRequest from a
// value of type *DestinationAccountTransactionRequestRequestBody.
func marshalDestinationAccountTransactionRequestRequestBodyToConnectDestinationAccountTransactionRequest(v *DestinationAccountTransactionRequestRequestBody) *connect.DestinationAccountTransactionRequest {
	if v == nil {
		return nil
	}
	res := &connect.DestinationAccountTransactionRequest{
		ReferenceNumber: v.ReferenceNumber,
		MobileNumber:    v.MobileNumber,
		Amount:          v.Amount,
		Narration:       v.Narration,
	}

	return res
}

// unmarshalSourceAccountResponseBodyToConnectviewsSourceAccountView builds a
// value of type *connectviews.SourceAccountView from a value of type
// *SourceAccountResponseBody.
func unmarshalSourceAccountResponseBodyToConnectviewsSourceAccountView(v *SourceAccountResponseBody) *connectviews.SourceAccountView {
	res := &connectviews.SourceAccountView{
		AccountNumber:       v.AccountNumber,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
		ResponseCode:        v.ResponseCode,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}

// unmarshalDestinationAccountResponseBodyToConnectviewsDestinationAccountView
// builds a value of type *connectviews.DestinationAccountView from a value of
// type *DestinationAccountResponseBody.
func unmarshalDestinationAccountResponseBodyToConnectviewsDestinationAccountView(v *DestinationAccountResponseBody) *connectviews.DestinationAccountView {
	res := &connectviews.DestinationAccountView{
		ReferenceNumber:     v.ReferenceNumber,
		AccountNumber:       v.AccountNumber,
		MobileNumber:        v.MobileNumber,
		PhoneNumber:         v.PhoneNumber,
		BankCode:            v.BankCode,
		Amount:              v.Amount,
		TransactionCurrency: v.TransactionCurrency,
		Narration:           v.Narration,
		TransactionID:       v.TransactionID,
		ResponseCode:        v.ResponseCode,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}
