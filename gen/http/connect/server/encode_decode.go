// Code generated by goa v3.1.3, DO NOT EDIT.
//
// connect HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/wondenge/coop-go/design

package server

import (
	"context"
	"io"
	"net/http"
	"strings"

	connect "github.com/wondenge/coop-go/gen/connect"
	connectviews "github.com/wondenge/coop-go/gen/connect/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeAccountBalanceResponse returns an encoder for responses returned by
// the connect AccountBalance endpoint.
func EncodeAccountBalanceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.AccountBalanceSuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewAccountBalanceResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeAccountBalanceRequest returns a decoder for requests sent to the
// connect AccountBalance endpoint.
func DecodeAccountBalanceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body AccountBalanceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAccountBalanceRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewAccountBalancePayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeAccountBalanceError returns an encoder for errors returned by the
// AccountBalance connect endpoint.
func EncodeAccountBalanceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountBalanceBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountBalanceUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountBalanceNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountBalanceTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeAccountFullStatementResponse returns an encoder for responses returned
// by the connect AccountFullStatement endpoint.
func EncodeAccountFullStatementResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.AccountFullStatementSuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewAccountFullStatementResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeAccountFullStatementRequest returns a decoder for requests sent to the
// connect AccountFullStatement endpoint.
func DecodeAccountFullStatementRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body AccountFullStatementRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAccountFullStatementRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewAccountFullStatementPayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeAccountFullStatementError returns an encoder for errors returned by
// the AccountFullStatement connect endpoint.
func EncodeAccountFullStatementError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountFullStatementBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountFullStatementUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountFullStatementNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountFullStatementNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountFullStatementTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeAccountMiniStatementResponse returns an encoder for responses returned
// by the connect AccountMiniStatement endpoint.
func EncodeAccountMiniStatementResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.AccountMiniStatementSuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewAccountMiniStatementResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeAccountMiniStatementRequest returns a decoder for requests sent to the
// connect AccountMiniStatement endpoint.
func DecodeAccountMiniStatementRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body AccountMiniStatementRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAccountMiniStatementRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewAccountMiniStatementPayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeAccountMiniStatementError returns an encoder for errors returned by
// the AccountMiniStatement connect endpoint.
func EncodeAccountMiniStatementError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountMiniStatementBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountMiniStatementUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountMiniStatementNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountMiniStatementNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountMiniStatementTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeAccountTransactionsResponse returns an encoder for responses returned
// by the connect AccountTransactions endpoint.
func EncodeAccountTransactionsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.AccountTransactionsSuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewAccountTransactionsResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeAccountTransactionsRequest returns a decoder for requests sent to the
// connect AccountTransactions endpoint.
func DecodeAccountTransactionsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body AccountTransactionsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAccountTransactionsRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewAccountTransactionsPayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeAccountTransactionsError returns an encoder for errors returned by the
// AccountTransactions connect endpoint.
func EncodeAccountTransactionsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountTransactionsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountTransactionsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountTransactionsNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountTransactionsTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeAccountValidationResponse returns an encoder for responses returned by
// the connect AccountValidation endpoint.
func EncodeAccountValidationResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.AccountValidationSuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewAccountValidationResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeAccountValidationRequest returns a decoder for requests sent to the
// connect AccountValidation endpoint.
func DecodeAccountValidationRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body AccountValidationRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateAccountValidationRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewAccountValidationPayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeAccountValidationError returns an encoder for errors returned by the
// AccountValidation connect endpoint.
func EncodeAccountValidationError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountValidationBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountValidationUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountValidationNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountValidationNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewAccountValidationTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeExchangeRateResponse returns an encoder for responses returned by the
// connect ExchangeRate endpoint.
func EncodeExchangeRateResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.ExchangeRateSuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewExchangeRateResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeExchangeRateRequest returns a decoder for requests sent to the connect
// ExchangeRate endpoint.
func DecodeExchangeRateRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body ExchangeRateRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateExchangeRateRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewExchangeRatePayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeExchangeRateError returns an encoder for errors returned by the
// ExchangeRate connect endpoint.
func EncodeExchangeRateError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExchangeRateBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExchangeRateUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExchangeRateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExchangeRateNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewExchangeRateTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeIFTAccountToAccountResponse returns an encoder for responses returned
// by the connect IFTAccountToAccount endpoint.
func EncodeIFTAccountToAccountResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.SuccessAcknowledgement)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewIFTAccountToAccountResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeIFTAccountToAccountRequest returns a decoder for requests sent to the
// connect IFTAccountToAccount endpoint.
func DecodeIFTAccountToAccountRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body IFTAccountToAccountRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateIFTAccountToAccountRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewIFTAccountToAccountTXNRequest(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeIFTAccountToAccountError returns an encoder for errors returned by the
// IFTAccountToAccount connect endpoint.
func EncodeIFTAccountToAccountError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.AcknowledgementError400)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*connect.AcknowledgementError403)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "conflict":
			res := v.(*connect.AcknowledgementError409)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewIFTAccountToAccountTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeINSSimulationResponse returns an encoder for responses returned by the
// connect INSSimulation endpoint.
func EncodeINSSimulationResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.SuccessAcknowledgement)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewINSSimulationResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeINSSimulationRequest returns a decoder for requests sent to the
// connect INSSimulation endpoint.
func DecodeINSSimulationRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body INSSimulationRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateINSSimulationRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewINSSimulationINSTransactionSimulationRequest(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeINSSimulationError returns an encoder for errors returned by the
// INSSimulation connect endpoint.
func EncodeINSSimulationError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "unauthorized":
			res := v.(*connect.ErrorAcknowledgement)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewINSSimulationUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewINSSimulationBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewINSSimulationNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewINSSimulationTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodePesaLinkSendToAccountResponse returns an encoder for responses
// returned by the connect PesaLinkSendToAccount endpoint.
func EncodePesaLinkSendToAccountResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.SuccessAcknowledgement)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewPesaLinkSendToAccountResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodePesaLinkSendToAccountRequest returns a decoder for requests sent to
// the connect PesaLinkSendToAccount endpoint.
func DecodePesaLinkSendToAccountRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body PesaLinkSendToAccountRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidatePesaLinkSendToAccountRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewPesaLinkSendToAccountTransactionRequest(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodePesaLinkSendToAccountError returns an encoder for errors returned by
// the PesaLinkSendToAccount connect endpoint.
func EncodePesaLinkSendToAccountError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.AcknowledgementError400)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*connect.AcknowledgementError403)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "conflict":
			res := v.(*connect.AcknowledgementError409)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToAccountTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodePesaLinkSendToPhoneResponse returns an encoder for responses returned
// by the connect PesaLinkSendToPhone endpoint.
func EncodePesaLinkSendToPhoneResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.SuccessAcknowledgement)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewPesaLinkSendToPhoneResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodePesaLinkSendToPhoneRequest returns a decoder for requests sent to the
// connect PesaLinkSendToPhone endpoint.
func DecodePesaLinkSendToPhoneRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body PesaLinkSendToPhoneRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidatePesaLinkSendToPhoneRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewPesaLinkSendToPhoneTransactionRequest(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodePesaLinkSendToPhoneError returns an encoder for errors returned by the
// PesaLinkSendToPhone connect endpoint.
func EncodePesaLinkSendToPhoneError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.AcknowledgementError400)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*connect.AcknowledgementError403)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "conflict":
			res := v.(*connect.AcknowledgementError409)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewPesaLinkSendToPhoneTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeSendToMPesaResponse returns an encoder for responses returned by the
// connect SendToMPesa endpoint.
func EncodeSendToMPesaResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.SuccessAcknowledgement)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewSendToMPesaResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeSendToMPesaRequest returns a decoder for requests sent to the connect
// SendToMPesa endpoint.
func DecodeSendToMPesaRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body SendToMPesaRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateSendToMPesaRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewSendToMPesaSendToMpesaTransactionRequest(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeSendToMPesaError returns an encoder for errors returned by the
// SendToMPesa connect endpoint.
func EncodeSendToMPesaError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.AcknowledgementError400)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*connect.AcknowledgementError403)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "conflict":
			res := v.(*connect.AcknowledgementError409)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewSendToMPesaTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeTransactionStatusResponse returns an encoder for responses returned by
// the connect TransactionStatus endpoint.
func EncodeTransactionStatusResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*connectviews.SuccessResponse)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewTransactionStatusOKResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeTransactionStatusRequest returns a decoder for requests sent to the
// connect TransactionStatus endpoint.
func DecodeTransactionStatusRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body TransactionStatusRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateTransactionStatusRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			accessToken string
		)
		accessToken = r.Header.Get("Authorization")
		if accessToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewTransactionStatusFTTransactionStatusPayload(&body, accessToken)
		if payload.AccessToken != nil {
			if strings.Contains(*payload.AccessToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.AccessToken, " ", 2)[1]
				payload.AccessToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeTransactionStatusError returns an encoder for errors returned by the
// TransactionStatus connect endpoint.
func EncodeTransactionStatusError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*connect.ErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewTransactionStatusBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*connect.MissingCredentials)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewTransactionStatusUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "not_found":
			res := v.(*connect.NotFoundErrorResponse)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewTransactionStatusNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "not_allowed":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewTransactionStatusNotAllowedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_allowed")
			w.WriteHeader(http.StatusMethodNotAllowed)
			return enc.Encode(body)
		case "timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewTransactionStatusTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "timeout")
			w.WriteHeader(http.StatusRequestTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalConnectMissingCredentialFaultToMissingCredentialFaultResponseBody
// builds a value of type *MissingCredentialFaultResponseBody from a value of
// type *connect.MissingCredentialFault.
func marshalConnectMissingCredentialFaultToMissingCredentialFaultResponseBody(v *connect.MissingCredentialFault) *MissingCredentialFaultResponseBody {
	if v == nil {
		return nil
	}
	res := &MissingCredentialFaultResponseBody{
		Code:        v.Code,
		Message:     v.Message,
		Description: v.Description,
	}

	return res
}

// marshalConnectviewsAccountTransactionViewToAccountTransactionResponseBody
// builds a value of type *AccountTransactionResponseBody from a value of type
// *connectviews.AccountTransactionView.
func marshalConnectviewsAccountTransactionViewToAccountTransactionResponseBody(v *connectviews.AccountTransactionView) *AccountTransactionResponseBody {
	if v == nil {
		return nil
	}
	res := &AccountTransactionResponseBody{
		TransactionID:         v.TransactionID,
		TransactionDate:       v.TransactionDate,
		ValueDate:             v.ValueDate,
		Narration:             v.Narration,
		TransactionType:       v.TransactionType,
		ServicePoint:          v.ServicePoint,
		TransactionReference:  v.TransactionReference,
		CreditAmount:          v.CreditAmount,
		DebitAmount:           v.DebitAmount,
		RunningClearedBalance: v.RunningClearedBalance,
		RunningBookBalance:    v.RunningBookBalance,
		DebitLimit:            v.DebitLimit,
		LimitExpiryDate:       v.LimitExpiryDate,
	}

	return res
}

// unmarshalSourceAccountTXNRequestRequestBodyToConnectSourceAccountTXNRequest
// builds a value of type *connect.SourceAccountTXNRequest from a value of type
// *SourceAccountTXNRequestRequestBody.
func unmarshalSourceAccountTXNRequestRequestBodyToConnectSourceAccountTXNRequest(v *SourceAccountTXNRequestRequestBody) *connect.SourceAccountTXNRequest {
	res := &connect.SourceAccountTXNRequest{
		AccountNumber:       *v.AccountNumber,
		Amount:              *v.Amount,
		TransactionCurrency: *v.TransactionCurrency,
		Narration:           *v.Narration,
	}

	return res
}

// unmarshalDestinationsTXNRequestRequestBodyToConnectDestinationsTXNRequest
// builds a value of type *connect.DestinationsTXNRequest from a value of type
// *DestinationsTXNRequestRequestBody.
func unmarshalDestinationsTXNRequestRequestBodyToConnectDestinationsTXNRequest(v *DestinationsTXNRequestRequestBody) *connect.DestinationsTXNRequest {
	res := &connect.DestinationsTXNRequest{}
	if v.DestinationsTXNRequest != nil {
		res.DestinationsTXNRequest = make([]*connect.DestinationAccountTXNRequest, len(v.DestinationsTXNRequest))
		for i, val := range v.DestinationsTXNRequest {
			res.DestinationsTXNRequest[i] = unmarshalDestinationAccountTXNRequestRequestBodyToConnectDestinationAccountTXNRequest(val)
		}
	}

	return res
}

// unmarshalDestinationAccountTXNRequestRequestBodyToConnectDestinationAccountTXNRequest
// builds a value of type *connect.DestinationAccountTXNRequest from a value of
// type *DestinationAccountTXNRequestRequestBody.
func unmarshalDestinationAccountTXNRequestRequestBodyToConnectDestinationAccountTXNRequest(v *DestinationAccountTXNRequestRequestBody) *connect.DestinationAccountTXNRequest {
	if v == nil {
		return nil
	}
	res := &connect.DestinationAccountTXNRequest{
		ReferenceNumber:     *v.ReferenceNumber,
		AccountNumber:       *v.AccountNumber,
		Amount:              *v.Amount,
		TransactionCurrency: *v.TransactionCurrency,
		Narration:           *v.Narration,
	}

	return res
}

// unmarshalCustMemoRequestBodyToConnectCustMemo builds a value of type
// *connect.CustMemo from a value of type *CustMemoRequestBody.
func unmarshalCustMemoRequestBodyToConnectCustMemo(v *CustMemoRequestBody) *connect.CustMemo {
	res := &connect.CustMemo{
		CustMemoLine1: v.CustMemoLine1,
		CustMemoLine2: v.CustMemoLine2,
		CustMemoLine3: v.CustMemoLine3,
	}

	return res
}

// unmarshalSourceAccountTransactionRequestRequestBodyToConnectSourceAccountTransactionRequest
// builds a value of type *connect.SourceAccountTransactionRequest from a value
// of type *SourceAccountTransactionRequestRequestBody.
func unmarshalSourceAccountTransactionRequestRequestBodyToConnectSourceAccountTransactionRequest(v *SourceAccountTransactionRequestRequestBody) *connect.SourceAccountTransactionRequest {
	res := &connect.SourceAccountTransactionRequest{
		AccountNumber:       *v.AccountNumber,
		Amount:              *v.Amount,
		TransactionCurrency: *v.TransactionCurrency,
		Narration:           *v.Narration,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}

// unmarshalDestinationsTransactionRequestRequestBodyToConnectDestinationsTransactionRequest
// builds a value of type *connect.DestinationsTransactionRequest from a value
// of type *DestinationsTransactionRequestRequestBody.
func unmarshalDestinationsTransactionRequestRequestBodyToConnectDestinationsTransactionRequest(v *DestinationsTransactionRequestRequestBody) *connect.DestinationsTransactionRequest {
	res := &connect.DestinationsTransactionRequest{}
	if v.DestinationAccountTransactionRequest != nil {
		res.DestinationAccountTransactionRequest = make([]*connect.DestinationAccountTransactionRequest, len(v.DestinationAccountTransactionRequest))
		for i, val := range v.DestinationAccountTransactionRequest {
			res.DestinationAccountTransactionRequest[i] = unmarshalDestinationAccountTransactionRequestRequestBodyToConnectDestinationAccountTransactionRequest(val)
		}
	}

	return res
}

// unmarshalDestinationAccountTransactionRequestRequestBodyToConnectDestinationAccountTransactionRequest
// builds a value of type *connect.DestinationAccountTransactionRequest from a
// value of type *DestinationAccountTransactionRequestRequestBody.
func unmarshalDestinationAccountTransactionRequestRequestBodyToConnectDestinationAccountTransactionRequest(v *DestinationAccountTransactionRequestRequestBody) *connect.DestinationAccountTransactionRequest {
	if v == nil {
		return nil
	}
	res := &connect.DestinationAccountTransactionRequest{
		ReferenceNumber: *v.ReferenceNumber,
		MobileNumber:    *v.MobileNumber,
		Amount:          *v.Amount,
		Narration:       *v.Narration,
	}

	return res
}

// marshalConnectviewsSourceAccountViewToSourceAccountResponseBody builds a
// value of type *SourceAccountResponseBody from a value of type
// *connectviews.SourceAccountView.
func marshalConnectviewsSourceAccountViewToSourceAccountResponseBody(v *connectviews.SourceAccountView) *SourceAccountResponseBody {
	res := &SourceAccountResponseBody{
		AccountNumber:       *v.AccountNumber,
		Amount:              *v.Amount,
		TransactionCurrency: *v.TransactionCurrency,
		Narration:           *v.Narration,
		ResponseCode:        v.ResponseCode,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}

// marshalConnectviewsDestinationAccountViewToDestinationAccountResponseBody
// builds a value of type *DestinationAccountResponseBody from a value of type
// *connectviews.DestinationAccountView.
func marshalConnectviewsDestinationAccountViewToDestinationAccountResponseBody(v *connectviews.DestinationAccountView) *DestinationAccountResponseBody {
	res := &DestinationAccountResponseBody{
		ReferenceNumber:     *v.ReferenceNumber,
		AccountNumber:       *v.AccountNumber,
		MobileNumber:        v.MobileNumber,
		PhoneNumber:         v.PhoneNumber,
		BankCode:            v.BankCode,
		Amount:              *v.Amount,
		TransactionCurrency: *v.TransactionCurrency,
		Narration:           *v.Narration,
		TransactionID:       v.TransactionID,
		ResponseCode:        v.ResponseCode,
		ResponseDescription: v.ResponseDescription,
	}

	return res
}
